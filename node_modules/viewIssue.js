/* viewIssue.js 
 */
var dbAccess = require('dbAccess'), 
	querystring = require('querystring'),
	reputation = require('reputation'), 
	tags = require('tags'),
	url = require('url'),
	users = require('users'),
	emailUtil = require('emailUtil');

var g_UserId = -1;
var g_UserVote; 
var thisIssueId;

var ViewIssue = exports.ViewIssue = function() {};

/**
 * Send the HTML page to the client
 * @param response Response object to send the data
 * @param issue Issue to display
 */
function displayPage(response, issue) {

	return function(error, users) {
		thisIssueId = issue['id'];
		
		// query view count and update it for current issue
		var sqlViewCount =  "SELECT views FROM issues WHERE id = " + thisIssueId;
		dbAccess.runQuery(sqlViewCount, function(error, views) {
			if (error) throw error;
		
			var viewcount = views[0]['views'];
			if (!viewcount)
				viewcount = 1;
			else
				viewcount += 1;
				
			dbAccess.update('issues', { values:[ 'views="' + viewcount + '"' ], 
			conditions:['id="' + thisIssueId + '"'] }, function(error) { 
				if (error) throw error;
			}); 
		});
		
		var user = users[0];

		g_UserVote = -1; //Assume that the user hasn't voted initially

		//Check if the user has already voted
		var sqlAlreadyVoted = "SELECT * FROM votes WHERE user_id = " + g_UserId + " AND issue_id = " + issue['id'];

		dbAccess.runQuery(sqlAlreadyVoted, function(error, rows_vote) {
			if (error) throw error;
			if (rows_vote.length == 1) {
				g_UserVote = rows_vote[0]['vote'];
			}

			var sqlQuery = "SELECT id,content,user_id,created FROM comments WHERE issue_id=" + thisIssueId + " ORDER BY created ASC";
			dbAccess.runQuery(sqlQuery, function (error, rows) {
				if (error) throw error;

				var sqlQuery2 = "SELECT id,name FROM users";
				dbAccess.runQuery(sqlQuery2, function (error, rows2) {
					if (error) throw error;

					contentArray = []; 

					if (rows.length > 0) {
						var name = "";
						var buttonType = "";
						for (var i = 0; i <= rows.length - 1; i++) {
							for (var j = 0; j <= rows2.length - 1; j++) {
								if (rows2[j].id == rows[i].user_id) {
									name = rows2[j].name;
									break;
								}
							}
							if(rows[i].user_id == g_UserId)
								buttonType = "button";
							else
								buttonType = "hidden";
							var obj = {
								iCommentCreatorId : rows[i].user_id,
								iCommentCreatorName : name,
								iCommentCreatedTime : rows[i].created,
								iCommentContent : rows[i].content,
								iButtonType : buttonType,
								iCommentId : rows[i].id,
								iIssueId : thisIssueId
							};
							contentArray.push(obj);
						}
					}
					getStats(thisIssueId, function(issueStats) {
						getFollow(g_UserId, thisIssueId, function(follows) {
						  
							tags.getTagsList(issue.id, function(tagList) {
								var tags = [];
								for (i = 0; i < tagList.length; i++) {
									var t = { name : tagList[i] };
									tags.push(t);
								}
								
								variables = {
									found: true,
									quickTaskButtons_partial: 'views/layouts/partials/quickTaskButtons_partial.html',
									quickTaskButtons: {id: issue.id},
									title: issue.title,
									created: issue.created,
									user: user,
									user_id: user.id,
									user_name: user.name,
									status: issue.status,
									location: issue.location,
									description: issue.description,
									link: issue.link,
									file_name: issue.fileLocation,
									file_link: 'uploads/'+issue.id+'/'+issue.fileLocation,
									issue_id: issue.id,
									userHasVoted: g_UserVote != -1,
									userLiked: g_UserVote == 0,
									comments: contentArray,
									// vars for issue stats
									lastModified: issue.lastModified,
									numComments: issueStats[0],
									numFollowers: issueStats[1],
									numViews: issueStats[2],
									tags: tags,
									following: follows
								}
								response.render('views/viewIssue.html', variables);
							});
						});  
					}); // end of queries of issue stats
				});
			});
		});
   };
}

/**
* Queries the DB for issue statistics such as number of comments, followers, and views
* @param thisIssueId Current issue
*/
function getStats(thisIssueId, callback) {
	// find number of followers
	var queryFollowers= "SELECT count (*) FROM follows WHERE issue_id = " + thisIssueId;
	// find number of comments
	var queryComments= "SELECT count (*) FROM comments  WHERE issue_id = " + thisIssueId;
	// find view count
	var queryViews= "SELECT views FROM issues WHERE id = " + thisIssueId;
	
	 dbAccess.runQuery(queryFollowers, function (error, followers) {
		if (error) throw error;
			dbAccess.runQuery(queryComments, function (error, comments) {
				if (error) throw error;
					dbAccess.runQuery(queryViews, function (error, views) {
						if (error) throw error;
						
						var stat;
						var issueStats = [0,0,0];
	
						issueStats[0] = comments[0]['count (*)'];
						issueStats[1] = followers[0]['count (*)'];
						issueStats[2] = views[0]['views'];
						
						if (callback instanceof Function) { callback(issueStats); } 
					});
			});
		});
}

function getFollow(g_UserId, thisIssueID, callback) {
	var isfollowing;
	var findFollowing = "SELECT * FROM (SELECT * FROM follows WHERE issue_id=" + thisIssueID + ") WHERE user_id=" + g_UserId;
	//console.log(findFollowing);
	dbAccess.runQuery(findFollowing, function(error, follows){
		if(error) throw error;
		if(callback instanceof Function) { callback(follows); }
	});
}

ViewIssue.addcomments = function (req,res) {
	var requestString = "";

	if (g_UserId == -1) {
		res.statusCode = 302;
		res.setHeader('Location', '/signin');
		res.end();
	}
	else {
		req.on('data', function (chunk) {
			requestString = requestString + chunk;
		});
		req.on('end', function() {
			var decodedBody = querystring.parse(requestString);
			var sqlQuery = "INSERT INTO comments (id,user_id,issue_id,content) VALUES ("
			+ null + ",'"
			+ g_UserId + "','"
			+ thisIssueId + "','"
			+ decodedBody.comments
			+ "')";
			dbAccess.runQuery(sqlQuery, function (error, rows) {
				if(error) throw error;
				res.statusCode = 302;
				res.setHeader('Location', '/viewIssue?id=' + thisIssueId);
				res.end();
			});
			
			// sending email notification to the issue's owner that a new comment has been posted
			dbAccess.find('users', { conditions:['id="' + g_UserId + '"']}, function(error, this_user){
				if (error) throw error;
				if (this_user) {
					dbAccess.find('issues', { conditions:['id="' + thisIssueId + '"']}, function(error, issue_owner){
					    if (error) throw error;
				        if (issue_owner) {					
							dbAccess.find('users', { conditions:['id="' + issue_owner[0].user_id + '"']}, function(error, owner){
								if (error) throw error;
								if (owner) {
									console.log('sending notification to user: ' + issue_owner[0].user_id + ' with email: ' + owner[0].email);
									var subject = '[CivicConnect] ' + this_user[0].name + ' has commented on your issue';
									var body =  'Issue: ' + issue_owner[0].title + '\n\n' +
												this_user[0].name + ' says, "' +
												decodedBody.comments + '"\n';										

									//console.log('subject: ' + subject);
									//console.log(body);

									/*
									emailUtil.sendPlainTextEmailToUserId(issue_owner[0].user_id, subject, body, function(error, success) {
										if (error)
											console.log('Error sending notification email to ' + owner[0].email);
										else 
											console.log('Notification email sent successfully to ' + owner[0].name + ' ' + owner[0].email);
									});
									*/

									emailUtil.sendPlainTextEmailToAddress('matt.malinao@gmail.com', subject, body, function(error,success) {
										if (error)
											console.log('Error sending notification email to ' + owner[0].email);
										else 
											console.log('Notification email sent successfully to ' + owner[0].name + ' ' + owner[0].email);		
									});

								}
							});		
						}					
					});
				}
			});
			
			reputation.updateOnAddComment(thisIssueId, g_UserId, decodedBody.comments); 
		});
	}
}

/**
* Retrieve the user corresponding to the issue
* @param response Response object to send the data
*/
function findIssueCreator(response, issueId) {
	return function(error, rows) {
		if (error) throw error;

		var issue = rows[0];

		if (issue == undefined) {
			variables = { found: false, issue_id: issueId }
			response.render('views/viewIssue.html', variables);
		}
		else
			dbAccess.runQuery('SELECT * FROM users WHERE id=' + issue['user_id'], displayPage(response, issue));
	};
}

/**
 * Main function of the module
 * @param request Incoming request
 * @param response Response object to send the data
 */
ViewIssue.display = function(request, response) {
	var parsedURL = url.parse(request.url, true);
	
	// Check to see if we have an issue id from the url
	if (!parsedURL.query.id) {
		// If not, we'll render the page now
		var variables = {
			found: false,
			issue_id: 'null'
		};
		response.render('views/viewIssue.html', variables);
	}
	else {
		// Otherwise, we can proceed normally
		var issueId = parsedURL.query.id;
		request.getUser(function(error, user) {
			if (error) {
				util.log('Error getting current user in viewIssue.display. ' + error);
				var variables = {
					error: 'Internal Server Error: Error retrieving current user'
				};
				response.render('views/viewIssue.html', variables);
			}
			if (user) g_UserId = user.id;
			var sqlQuery = "SELECT * FROM issues WHERE id='" + issueId + "';";
			dbAccess.runQuery(sqlQuery, findIssueCreator(response, issueId));
		});
	}

};
